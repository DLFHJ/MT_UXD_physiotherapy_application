<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Physiotherapy App - Combined UI</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@600&family=Inter:wght@400;500&family=Nunito:wght@700&display=swap" rel="stylesheet">
    <style>
        /* --- CSS styling --- */
        /* Styling is included in this file to keep the prototype self-contained in one central file */
        :root {
            --calm-teal: #3BA99C;
            --fresh-sage: #A8D5BA;
            --warm-coral: #F38181;
            --soft-yellow: #FCE38A;
            --light-gray: #F5F6F7;
            --charcoal-gray: #333333;
        }

        body {
            margin: 0;
            font-family: 'Inter', sans-serif;
            background-color: var(--light-gray);
            color: var(--charcoal-gray);
        }
        
        h1, h2, h3 {
            font-family: 'Poppins', sans-serif;
            color: var(--calm-teal);
            text-align: center;
        }

        /* --- Screen Management --- */
        /* set up styling for all different screens */
        .screen {
            display: none;
            width: 100%;
            min-height: 100vh;
            box-sizing: border-box;
        }
        .screen.active {
            display: block;
        }

        #selection-screen {
            padding: 20px;
            overflow-y: auto;
        }
        
        .selection-container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .exercise-cards-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
            margin-bottom: 20px;
        }

        .exercise-card {
            background: #fff;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.05);
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 20px;
            align-items: center;
        }
        .exercise-card-controls {
            text-align: center;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        .exercise-card-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 10px;
        }
        
        .exercise-image {
            width: 100%;
            max-width: 150px;
            height: auto;
            border-radius: 8px;
            margin: 0 auto;
            object-fit: cover;
            aspect-ratio: 1/1;
        }

        /* --- Main Container Layouts --- */
        .main-container {
             display: grid;
             height: 100vh;
             padding: 20px;
             box-sizing: border-box;
             gap: 20px;
        }

        #two-screen-layout {
            grid-template-rows: 1fr auto auto;
            grid-template-columns: 1fr 1fr;
        }

        #one-screen-layout {
             grid-template-rows: 1fr auto auto;
             grid-template-columns: 1fr;
             display: none; /* Hidden by default */
        }
        
        .camera-view, .skeleton-view {
            grid-row: 1 / 2;
            background-color: #fff;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.05);
            padding: 15px;
            display: flex;
            flex-direction: column;
        }

        #two-screen-layout .camera-view { grid-column: 1 / 2; }
        #two-screen-layout .skeleton-view { grid-column: 2 / 3; }
        #one-screen-layout .camera-view { grid-column: 1 / -1; }

        .video-container {
            position: relative;
            width: 100%;
            background: #000;
            border-radius: 8px;
            overflow: hidden;
            aspect-ratio: 16/9;
            flex-grow: 1;
        }
        
        #input_video, #output_canvas {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }

        #output_canvas { z-index: 10; }
        
        /* note: Three.js was used for the 3D rendering of the skeleton */
        #threejs-container {
            width: 100%;
            height: 100%;
            background: var(--charcoal-gray);
            border-radius: 8px;
            position: relative;
        }
        
        .controls {
            grid-row: 2 / 3;
            grid-column: 1 / -1;
            display: flex;
            gap: 10px;
            justify-content: center;
            align-items: center;
        }
        
        button {
            padding: 12px 16px;
            font-family: 'Inter', sans-serif;
            font-weight: 500;
            font-size: 16px;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        button:hover:not(:disabled) { transform: translateY(-2px); box-shadow: 0 4px 8px rgba(0,0,0,0.15); }
        button:disabled { background: #ccc; cursor: not-allowed; }

        .start-exercise-btn { background-color: var(--calm-teal); }
        .stop-btn, #close-summary { background-color: var(--warm-coral); }
        .mute-btn, .toggle-btn { background-color: #607d8b; }
        
        .dynamic-tracking {
            background-color: #fff;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.05);
            padding: 20px;
            grid-row: 3 / 4;
        }

        #two-screen-layout .dynamic-tracking { grid-column: 1 / 3; }
        #one-screen-layout .dynamic-tracking { grid-column: 1 / -1; }


        .tracking-grid {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 20px;
        }

        .exercise-stats {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            flex-grow: 1;
        }
        
        .stat-box { background: var(--light-gray); padding: 15px; border-radius: 8px; text-align: center; }
        .stat-value { font-family: 'Poppins', sans-serif; font-size: 28px; font-weight: 600; color: var(--calm-teal); }
        .stat-label { font-size: 14px; color: #666; }
        
        .phase-indicator {
            font-size: 18px; font-weight: bold; padding: 10px;
            border-radius: 8px; text-align: center; margin-bottom: 15px;
            background: #eee; color: var(--charcoal-gray); transition: background-color 0.5s;
        }
        
        .feedback-container {
            flex-grow: 1;
            background: var(--light-gray);
            border-radius: 8px;
            padding: 15px;
        }
        .feedback-container h3 { margin: 0 0 10px 0; font-family: 'Poppins', sans-serif; }
        #feedback-text { font-size: 16px; color: var(--charcoal-gray); min-height: 40px; }

        #summary-modal {
            display: none; position: fixed; z-index: 1000;
            left: 0; top: 0; width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.7);
            justify-content: center; align-items: center;
        }

        .summary-content {
            background-color: #fff; color: var(--charcoal-gray);
            padding: 30px; border-radius: 12px;
            width: 90%; max-width: 500px; text-align: center;
            box-shadow: 0 8px 30px rgba(0,0,0,0.2);
        }

        .summary-grid {
            display: grid; grid-template-columns: 1fr 1fr;
            gap: 20px; margin: 25px 0;
        }
        
        .info-panel {
            background: #fff;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.05);
        }

        .history-log {
            margin-top: 15px;
            max-height: 200px;
            overflow-y: auto;
            background-color: var(--light-gray);
            border-radius: 8px;
            padding: 10px;
        }

        .history-item {
            display: flex;
            justify-content: space-between;
            padding: 8px;
            border-bottom: 1px solid #ddd;
        }

        .history-item:last-child {
            border-bottom: none;
        }

        .chart-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .chart-tab {
            padding: 8px 16px;
            background-color: var(--light-gray);
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        .chart-tab.active {
            background-color: var(--calm-teal);
            color: white;
        }
        
        #motivational-popup {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: var(--soft-yellow);
            color: var(--charcoal-gray);
            padding: 20px 40px;
            border-radius: 12px;
            font-family: 'Nunito', sans-serif;
            font-size: 24px;
            z-index: 2000;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            opacity: 0;
            transition: opacity 0.5s ease;
        }
        
        .post-session-feedback {
            margin-top: 25px;
            padding-top: 20px;
            border-top: 1px solid #eee;
        }

        .rest-message {
            font-family: 'Nunito', sans-serif;
            font-size: 18px;
            color: var(--calm-teal);
        }

        .emoji-selection {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 10px;
        }

        .emoji {
            font-size: 36px;
            cursor: pointer;
            transition: transform 0.2s, text-shadow 0.2s;
        }

        .emoji:hover {
            transform: scale(1.2);
        }

        .emoji.selected {
            transform: scale(1.3);
            text-shadow: 0 0 10px var(--soft-yellow);
        }

        #rest-timer {
            font-size: 24px;
            font-family: 'Poppins', sans-serif;
            color: var(--warm-coral);
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <!-- Setup of the HTML structure, defining the UI of the prototype -->
    <!-- Exercise Selection screen -->
    <div id="selection-screen" class="screen active">
        <h1>Physiotherapy Assistant</h1>
        <div class="selection-container">
            <div class="exercise-cards-container">
                 <div class="exercise-card">
                    <div class="exercise-card-controls">
                        <h3>Squat</h3>
                        <img src="https://raw.githubusercontent.com/DLFHJ/MT_UXD_physiotherapy_application/refs/heads/main/images/squat.png" alt="Squat illustration" class="exercise-image" onerror="this.onerror=null;this.src='https://placehold.co/150x150/A8D5BA/333333?text=Squat';">
                        <button class="start-exercise-btn" data-exercise="squat">Start Squats</button>
                    </div>
                    <div class="exercise-card-stats">
                        <div class="stat-box"><div class="stat-value" id="squat-total-reps">0</div><div class="stat-label">Total Reps</div></div>
                        <div class="stat-box"><div class="stat-value" id="squat-total-sets">0</div><div class="stat-label">Total Sets</div></div>
                        <div class="stat-box"><div class="stat-value" id="squat-best-quality">--</div><div class="stat-label">Best Quality</div></div>
                    </div>
                </div>
                 <div class="exercise-card">
                    <div class="exercise-card-controls">
                        <h3>Bicep Curl</h3>
                        <img src="https://raw.githubusercontent.com/DLFHJ/MT_UXD_physiotherapy_application/refs/heads/main/images/curl.png" alt="Bicep Curl illustration" class="exercise-image" onerror="this.onerror=null;this.src='https://placehold.co/150x150/A8D5BA/333333?text=Bicep+Curl';">
                        <button class="start-exercise-btn" data-exercise="bicep_curl">Start Bicep Curls</button>
                    </div>
                     <div class="exercise-card-stats">
                        <div class="stat-box"><div class="stat-value" id="bicep_curl-total-reps">0</div><div class="stat-label">Total Reps</div></div>
                        <div class="stat-box"><div class="stat-value" id="bicep_curl-total-sets">0</div><div class="stat-label">Total Sets</div></div>
                        <div class="stat-box"><div class="stat-value" id="bicep_curl-best-quality">--</div><div class="stat-label">Best Quality</div></div>
                    </div>
                </div>
            </div>
            <div class="info-panel">
                <h2>Session History</h2>
                <div id="history-log" class="history-log"></div>
            </div>
            <div class="info-panel" style="margin-top: 20px;">
                <h2>Progress Over Time</h2>
                <div class="chart-tabs">
                    <div class="chart-tab active" data-exercise="Squat">Squat Quality</div>
                    <div class="chart-tab" data-exercise="Bicep Curl">Bicep Curl Quality</div>
                </div>
                <canvas id="progress-chart"></canvas>
            </div>
        </div>
    </div>

    <!-- Exercise Screen -->
    <div id="exercise-screen" class="screen">
        <!-- Two Screen Layout -->
        <div id="two-screen-layout" class="main-container">
            <div class="camera-view">
                <h2>Camera View</h2>
                <div class="video-container">
                    <video id="input_video" playsinline></video>
                    <canvas id="output_canvas"></canvas>
                </div>
            </div>
            <div class="skeleton-view">
                <h2>3D Skeleton View</h2>
                <div id="threejs-container"></div>
                 <div class="info-panel" style="margin-top: 15px; text-align: center;">
                    <div id="status" class="status">Ready to start</div>
                    <strong>Detected Joints:</strong> <span id="joint-count">0</span>/33
                </div>
            </div>
            <div class="controls">
                <button id="stop-exercise-btn" class="stop-btn" disabled="">Stop Exercise</button>
                <button id="mute-btn" class="mute-btn">🔊 Mute</button>
                <button id="toggle-view-btn" class="toggle-btn">Toggle View</button>
            </div>
            <div class="dynamic-tracking">
                <div id="exercise-phase-two-screen" class="phase-indicator">Ready to start exercise</div>
                <div class="tracking-grid">
                    <div class="exercise-stats">
                        <div class="stat-box"><div class="stat-value" id="set-count-two-screen">0</div><div class="stat-label">Sets</div></div>
                        <div class="stat-box"><div class="stat-value" id="rep-count-two-screen">0 / 5</div><div class="stat-label">Reps / Goal</div></div>
                        <div class="stat-box"><div class="stat-value" id="current-quality-two-screen">--</div><div class="stat-label">Quality</div></div>
                        <div class="stat-box"><div class="stat-value" id="exercise-time-two-screen">0:00</div><div class="stat-label">Time</div></div>
                    </div>
                     <div class="feedback-container">
                        <h3>Real-time Feedback</h3>
                        <div id="feedback-text-two-screen">Start an exercise to see real-time form feedback.</div>
                        <div id="rest-timer-two-screen"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- One Screen Layout -->
        <div id="one-screen-layout" class="main-container">
            <div class="camera-view">
                <h2>Camera View</h2>
                <div class="video-container">
                    <!-- Video and canvas are shared, no need to duplicate -->
                </div>
            </div>
            <div class="controls">
                <button id="stop-exercise-btn-one-screen" class="stop-btn" disabled="">Stop Exercise</button>
                <button id="mute-btn-one-screen" class="mute-btn">🔊 Mute</button>
                <button id="toggle-view-btn-one-screen" class="toggle-btn">Toggle View</button>
            </div>
            <div class="dynamic-tracking">
                 <div id="exercise-phase-one-screen" class="phase-indicator">Ready to start exercise</div>
                 <div class="tracking-grid">
                     <div class="exercise-stats">
                         <div class="stat-box"><div class="stat-value" id="set-count-one-screen">0</div><div class="stat-label">Sets</div></div>
                        <div class="stat-box"><div class="stat-value" id="rep-count-one-screen">0 / 5</div><div class="stat-label">Reps / Goal</div></div>
                        <div class="stat-box"><div class="stat-value" id="current-quality-one-screen">--</div><div class="stat-label">Quality</div></div>
                        <div class="stat-box"><div class="stat-value" id="exercise-time-one-screen">0:00</div><div class="stat-label">Time</div></div>
                    </div>
                     <div class="feedback-container">
                        <h3>Real-time Feedback</h3>
                        <div id="feedback-text-one-screen">Start an exercise to see real-time form feedback.</div>
                        <div id="rest-timer-one-screen"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="summary-modal">
        <div class="summary-content">
            <h2>Session Summary</h2>
            <div class="summary-grid">
                <div class="stat-box"><div class="stat-value" id="summary-sets">0</div><div class="stat-label">Total Sets</div></div>
                <div class="stat-box"><div class="stat-value" id="summary-reps">0</div><div class="stat-label">Total Reps</div></div>
                <div class="stat-box"><div class="stat-value" id="summary-quality">--</div><div class="stat-label">Avg. Quality</div></div>
                <div class="stat-box"><div class="stat-value" id="summary-time">0:00</div><div class="stat-label">Total Time</div></div>
            </div>
            <button id="close-summary">Close</button>
            
            <div class="post-session-feedback">
                <p class="rest-message">Good job on the exercise! Now rest for 5 minutes.</p>
                <p>How do you feel?</p>
                <div class="emoji-selection">
                    <span class="emoji">😊</span>
                    <span class="emoji">👍</span>
                    <span class="emoji">😐</span>
                    <span class="emoji">😥</span>
                    <span class="emoji">💪</span>
                </div>
            </div>
        </div>
    </div>
    
    <div id="motivational-popup"></div>

    <script>
        /* Main logic using JS starts here */
        // --- FRAMEWORK GLOBALS ---
        let pose, videoElement, scene, renderer, skeleton, camera;
        let isCameraOn = false;
        let cameraLoopId = null;
        let progressChart = null; // Note that Chart.js is used for the statistic graphics
        let isTwoScreenMode = true;

        // --- EXERCISE ENGINE GLOBALS ---
        /* Some of the less self descriptive variables are explained here */
        let isExerciseActive = false;
        let activeExercise = null; 
        let exerciseStartTime = null;
        let repCount = 0;
        let qualityScores = []; // An array to store the quality score of each movement phase
        let currentPhase = null; // The current part of the movement (e.g., 'standing', 'bottom' for a squat)
        let lastPhase = null;
        let setCount = 1;
        const repGoal = 5;
        let lastRepTime = 0; // Timestamp of the last rep, to prevent counting a single movement multiple times
        const REP_COOLDOWN = 1000; // Cooldown in ms
        let isResting = false;
        let restTimerId = null;

        // --- AUDIO FEEDBACK GLOBALS ---
        const synth = window.speechSynthesis; // The browser's built-in speech engine
        let isMuted = false;
        let lastSpokenMsg = ''; // The last message spoken, to avoid repetition
        let speechUtterance = new SpeechSynthesisUtterance(); // The object that holds the text to be spoken.
        let lastSpokenTime = 0; // Timestamp of the last spoken message, for cooldown.
        const SPEECH_COOLDOWN = 5000; // Cooldown in ms

        // --- EXERCISE LIBRARY ---
        /* Define exercise rules and logic for each available exercise */
        const EXERCISE_LIBRARY = {
            'squat': {
                name: 'Squat',
                repSequence: ['standing', 'bottom', 'standing'], // The required order of phases for one rep
                phases: { // Defines the different parts of the movement
                    'standing': {
                        thresholds: { rightKnee: 160, leftKnee: 160 },
                        condition: (angles, thresholds) => angles.rightKnee > thresholds.rightKnee && angles.leftKnee > thresholds.leftKnee,
                        feedback: "Ready to squat"
                    },
                    'bottom': {
                        thresholds: { rightKnee: 100, leftKnee: 100 },
                        condition: (angles, thresholds) => angles.rightKnee < thresholds.rightKnee && angles.leftKnee < thresholds.leftKnee,
                        feedback: "Good depth!"
                    }
                },
                // Calculates a quality score based on posture and symmetry
                getQuality: (pose) => {
                    const { landmarks, angles } = pose;
                    const posture = 100 - (Math.abs(landmarks[11].x - landmarks[23].x) * 200);
                    const symmetry = 100 - Math.abs(angles.leftKnee - angles.rightKnee);
                    return Math.max(0, (posture * 0.5) + (symmetry * 0.5));
                },
                // Generates real-time feedback text based on quality and angles
                getFeedback: (quality, angles) => {
                    let feedback = [];
                    if (quality < 70) feedback.push("Keep your weight balanced and back straight.");
                    if (angles.rightKnee < 90 && angles.leftKnee < 90) feedback.push("Great depth!");
                    return feedback.length > 0 ? feedback.join(' ') : 'Good form!';
                }
            },
            'bicep_curl': {
                name: 'Bicep Curl',
                repSequence: ['down', 'up', 'down'],
                phases: {
                    'down': {
                        thresholds: { rightElbow: 150 },
                        condition: (angles, thresholds) => angles.rightElbow > thresholds.rightElbow,
                        feedback: "Arm extended"
                    },
                    'up': {
                        thresholds: { rightElbow: 70 },
                        condition: (angles, thresholds) => angles.rightElbow < thresholds.rightElbow,
                        feedback: "Arm curled"
                    }
                },
                getQuality: (pose) => {
                    const { landmarks } = pose;
                    const lean = Math.abs(landmarks[12].x - landmarks[24].x);
                    return Math.max(0, 100 - (lean * 500));
                },
                getFeedback: (quality, angles) => {
                    let feedback = [];
                    if (quality < 80) feedback.push("Keep your back straight, avoid swinging.");
                    if (angles.rightElbow < 60) feedback.push("Excellent contraction!");
                    return feedback.length > 0 ? feedback.join(' ') : 'Looking good!';
                }
            }
        };

        const POSE_CONNECTIONS = [[11, 13], [13, 15], [12, 14], [14, 16], [11, 12], [23, 24], [11, 23], [12, 24], [23, 25], [25, 27], [24, 26], [26, 28]];
        
        // --- INITIALIZATION ---
        /* All important initial values and calls are made here */
        /* Initalise Three.js used for the 3D rendering of the skeleton */
        /* Just like most 3D engines camera and light need to be setup */
        function initThreeJS() {
            const container = document.getElementById('threejs-container');
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x333333);
            camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(0, 1.5, 4);
            camera.lookAt(0, 1, 0);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(0, 10, 5);
            scene.add(directionalLight);
            skeleton = new THREE.Group();
            scene.add(skeleton);

            /* Ability to rotate 3D model - was mostly used during debugging */
            let mouseDown = false, mouseX = 0, mouseY = 0;
            container.addEventListener('mousedown', (e) => { mouseDown = true; mouseX = e.clientX; mouseY = e.clientY; });
            container.addEventListener('mousemove', (e) => {
                if (!mouseDown) return;
                skeleton.rotation.y += (e.clientX - mouseX) * 0.01;
                skeleton.rotation.x += (e.clientY - mouseY) * 0.01;
                mouseX = e.clientX;
                mouseY = e.clientY;
            });
            container.addEventListener('mouseup', () => { mouseDown = false; });
            
            window.addEventListener('resize', () => {
                const container = document.getElementById('threejs-container');
                if (container.clientWidth > 0 && container.clientHeight > 0) {
                    renderer.setSize(container.clientWidth, container.clientHeight);
                    camera.aspect = container.clientWidth / container.clientHeight;
                    camera.updateProjectionMatrix();
                }
            });
        }

        /* Initialise MediaPipe used for AI detection/tracking of the body */
        /* This function is async because loading the model files takes time */
        async function initMediaPipe() {
            pose = new Pose({ 
                locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}` 
            });
            pose.setOptions({ 
                modelComplexity: 1, 
                smoothLandmarks: true, 
                minDetectionConfidence: 0.5, 
                minTrackingConfidence: 0.5 
            });
            pose.onResults(onResults);
            await pose.initialize();
        }

        // --- SINGLE ANIMATION LOOP ---
        /* Starts the animation loop for the 3D scene */
        function renderLoop() {
            requestAnimationFrame(renderLoop);
            if(renderer && scene && camera) {
                renderer.render(scene, camera);
            }
        }

        // --- DEDICATED CAMERA/AI LOOP ---
        /* Starts the loop which continuously sends frames from the camera to the MediaPipe model */
        async function cameraLoop() {
            if (isCameraOn && videoElement && videoElement.readyState >= 4) {
                await pose.send({image: videoElement});
            }
            cameraLoopId = requestAnimationFrame(cameraLoop);
        }

        // --- CORE PROCESSING LOGIC ---
        /* Can be though of as the "cental command center" - gest activated every time the MediaPipe AI model successfully analyzes a frame from the camera */
        /* roughly follows these steps:
            receive data, prepare canvas, check if person is detected, analyze pose (if a person was detected), update visual
        */
        function onResults(results) {
            const canvasCtx = document.getElementById('output_canvas').getContext('2d');
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasCtx.canvas.width, canvasCtx.canvas.height);
            canvasCtx.drawImage(results.image, 0, 0, canvasCtx.canvas.width, canvasCtx.canvas.height);

            let quality = null;
            if (results.poseLandmarks) {
                const angles = calculateJointAngles(results.poseLandmarks);
                
                if (isExerciseActive && !isResting) {
                    quality = processExercise(results.poseLandmarks, angles);
                }
                
                // Only update the 3D skeleton if it's visible
                if (isTwoScreenMode) {
                    updateSkeleton(results.poseLandmarks, quality);
                }
                
                // Draw the 2D skeleton overlay on the camera view
                const boneColor = getQualityColorForCanvas(quality);
                const jointColor = '#FFFFFF';

                drawConnectors(canvasCtx, results.poseLandmarks, POSE_CONNECTIONS, {color: boneColor, lineWidth: 4});
                drawLandmarks(canvasCtx, results.poseLandmarks, {color: jointColor, fillColor: boneColor, lineWidth: 2, radius: 5});
                drawAngleIndicatorsOnCanvas(angles, results.poseLandmarks, canvasCtx);
                
                document.getElementById('joint-count').textContent = results.poseLandmarks.length;
                document.getElementById('status').textContent = 'Pose detected';
            } else {
                // If no pose is detected, clear the UI
                document.getElementById('joint-count').textContent = '0';
                document.getElementById('status').textContent = 'No pose detected';
                if (isTwoScreenMode) {
                    updateSkeleton(null, null);
                }
            }
            canvasCtx.restore();
        }

        /* Analyzes the pose to count reps and calculate quality */
        function processExercise(landmarks, angles) {
            const now = Date.now();
            let newPhase = null;
            for (const phaseName in activeExercise.phases) {
                const phaseDef = activeExercise.phases[phaseName];
                if (phaseDef.condition(angles, phaseDef.thresholds)) {
                    newPhase = phaseName;
                    break;
                }
            }

            // If the phase has changed, check if a rep has been completed
            if (newPhase && newPhase !== currentPhase) {
                lastPhase = currentPhase;
                currentPhase = newPhase;
                updatePhaseDisplay(currentPhase);

                // A rep is counted when the user moves through the correct sequence of phases
                if (lastPhase === activeExercise.repSequence[1] && currentPhase === activeExercise.repSequence[2] && (now - lastRepTime > REP_COOLDOWN)) {
                    lastRepTime = now;
                    repCount++;
                    
                    if (repCount === 3) {
                        showMotivationalPopup("Halfway there, great job!");
                    }

                    if (repCount === repGoal) {
                        setCount++;
                        repCount = 0;
                        speak("Set complete", true);
                        startRestTimer(15);
                    } else {
                        speak(String(repCount), true);
                    }
                    
                    updateRepAndSetDisplay();
                }
            }

            const quality = activeExercise.getQuality({landmarks, angles});
            if (quality) {
                updateQualityDisplay(quality);
                qualityScores.push(quality);
                const feedback = activeExercise.getFeedback(quality, angles);
                updateFeedbackDisplay(feedback);
                speak(feedback);
            }
            return quality;
        }
        
        /* Calculate and display quality and feedback */
        function updateQualityDisplay(quality) {
             document.getElementById('current-quality-one-screen').textContent = `${quality.toFixed(0)}%`;
             document.getElementById('current-quality-two-screen').textContent = `${quality.toFixed(0)}%`;
        }

        function updateFeedbackDisplay(feedback) {
            document.getElementById('feedback-text-one-screen').textContent = feedback;
            document.getElementById('feedback-text-two-screen').textContent = feedback;
        }


        // --- UTILITY & UI FUNCTIONS ---
        /* Speak/Audio functionality using Web Speech API (which is provided by the browser) */
        function speak(text, force = false) {
            if (isMuted || !text) return;
            const now = Date.now();
            /* Clean up text */
            const plainText = text.replace(/<[^>]*>?/gm, '');

            if (force) {
                 if (synth.speaking) synth.cancel();
                 speechUtterance.text = plainText;
                 synth.speak(speechUtterance);
                 lastSpokenTime = now;
                 return;
            }

            if ((now - lastSpokenTime > SPEECH_COOLDOWN) && (plainText !== lastSpokenMsg)) {
                 if (synth.speaking) synth.cancel();
                 speechUtterance.text = plainText;
                 synth.speak(speechUtterance);
                 lastSpokenMsg = plainText;
                 lastSpokenTime = now;
            }
        }
        
        /* Manage popups */
        function showMotivationalPopup(message) {
            const popup = document.getElementById('motivational-popup');
            if (!popup) return;
            popup.textContent = message;
            popup.style.display = 'block';
            setTimeout(() => { popup.style.opacity = 1; }, 10);

            setTimeout(() => {
                popup.style.opacity = 0;
                setTimeout(() => {
                    popup.style.display = 'none';
                }, 500);
            }, 3000);
        }

        /* Calculate joint angles using x,y,z coordinates */
        /* Note that this system uses a right-handed coordinate system - very important for technical details */
        function calculateJointAngles(landmarks) {
            if (!landmarks || landmarks.length < 33) return {};
            const p = landmarks;
            return {
                rightElbow: calculateAngle(p[12], p[14], p[16]),
                leftElbow: calculateAngle(p[11], p[13], p[15]),
                rightKnee: calculateAngle(p[24], p[26], p[28]),
                leftKnee: calculateAngle(p[23], p[25], p[27]),
            };
        }

        function calculateAngle(p1, p2, p3) {
            if(!p1 || !p2 || !p3) return 0;
            const v1 = { x: p1.x - p2.x, y: p1.y - p2.y, z: (p1.z || 0) - (p2.z || 0) };
            const v2 = { x: p3.x - p2.x, y: p3.y - p2.y, z: (p3.z || 0) - (p2.z || 0) };
            const dot = v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;
            const mag1 = Math.sqrt(v1.x**2 + v1.y**2 + v1.z**2);
            const mag2 = Math.sqrt(v2.x**2 + v2.y**2 + v2.z**2);
            if (mag1 === 0 || mag2 === 0) return 0;
            return Math.acos(Math.max(-1, Math.min(1, dot / (mag1 * mag2)))) * (180 / Math.PI);
        }

        /* Gets called when an exercise is started - note the async keyword */
        /* Switches screens and initialises all important values */
        async function startExercise(exerciseKey) {
            if (!EXERCISE_LIBRARY[exerciseKey]) return;
            
            document.getElementById('selection-screen').classList.remove('active');
            document.getElementById('exercise-screen').classList.add('active');
            
            if (isTwoScreenMode) {
                 const container = document.getElementById('threejs-container');
                 if(renderer) {
                    renderer.setSize(container.clientWidth, container.clientHeight);
                    camera.aspect = container.clientWidth / container.clientHeight;
                    camera.updateProjectionMatrix();
                 }
            }

            await startCamera();

            activeExercise = EXERCISE_LIBRARY[exerciseKey];
            isExerciseActive = true;
            exerciseStartTime = Date.now();
            repCount = 0;
            setCount = 1;
            qualityScores = [];
            currentPhase = activeExercise.repSequence[0];
            
            updateRepAndSetDisplay();
            updateQualityDisplay({toFixed: () => '--'});
            document.getElementById('stop-exercise-btn').disabled = false;
            document.getElementById('stop-exercise-btn-one-screen').disabled = false;
            updatePhaseDisplay(currentPhase);
            speak(`Starting ${activeExercise.name} exercise. Goal is ${repGoal} reps.`);
        }

        function stopExercise() {
            showSummary();
            isExerciseActive = false;
            activeExercise = null;
            stopCamera();
        }

        function resetExerciseState() {
            updatePhaseDisplay('Select a new exercise.');
            updateFeedbackDisplay('Great work! Select a new exercise.');
            
            document.getElementById('set-count-one-screen').textContent = '0';
            document.getElementById('set-count-two-screen').textContent = '0';
            document.getElementById('rep-count-one-screen').textContent = `0 / ${repGoal}`;
            document.getElementById('rep-count-two-screen').textContent = `0 / ${repGoal}`;
            updateQualityDisplay({toFixed: () => '--'});
            document.getElementById('exercise-time-one-screen').textContent = '0:00';
            document.getElementById('exercise-time-two-screen').textContent = '0:00';
        }

        /* Pop-up showing the exercise summary and statistics */
        function showSummary() {
            const totalReps = ((setCount - 1) * repGoal) + repCount;
            const avgQuality = qualityScores.length > 0 ? (qualityScores.reduce((a, b) => a + b, 0) / qualityScores.length).toFixed(0) + '%' : 'N/A';
            const elapsedTime = Math.floor((Date.now() - exerciseStartTime) / 1000);
            const minutes = Math.floor(elapsedTime / 60);
            const seconds = elapsedTime % 60;

            document.getElementById('summary-sets').textContent = setCount - 1;
            document.getElementById('summary-reps').textContent = totalReps;
            document.getElementById('summary-quality').textContent = avgQuality;
            document.getElementById('summary-time').textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;

            document.getElementById('summary-modal').style.display = 'flex';
            
            saveSession(activeExercise.name, setCount - 1, totalReps, avgQuality);
        }

        /* Updates the phase indicator text */
        function updatePhaseDisplay(phase) {
            const phaseElementOne = document.getElementById('exercise-phase-one-screen');
            const phaseElementTwo = document.getElementById('exercise-phase-two-screen');
            
            if (activeExercise && activeExercise.phases[phase]) {
                const text = activeExercise.phases[phase].feedback;
                if(phaseElementOne) phaseElementOne.textContent = text;
                if(phaseElementTwo) phaseElementTwo.textContent = text;
            } else if (typeof phase === 'string') {
                 if(phaseElementOne) phaseElementOne.textContent = phase;
                 if(phaseElementTwo) phaseElementTwo.textContent = phase;
            }
        }
        
        function updateRepAndSetDisplay() {
            document.getElementById('rep-count-one-screen').textContent = `${repCount} / ${repGoal}`;
            document.getElementById('rep-count-two-screen').textContent = `${repCount} / ${repGoal}`;
            document.getElementById('set-count-one-screen').textContent = setCount;
            document.getElementById('set-count-two-screen').textContent = setCount;
        }

        setInterval(() => {
            if (isExerciseActive) {
                const elapsed = Math.floor((Date.now() - exerciseStartTime) / 1000);
                const minutes = Math.floor(elapsed / 60);
                const seconds = elapsed % 60;
                const timeString = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                document.getElementById('exercise-time-one-screen').textContent = timeString;
                document.getElementById('exercise-time-two-screen').textContent = timeString;
            }
        }, 1000);

        function getQualityColor(quality) {
            const red = new THREE.Color(0xff4444);
            const yellow = new THREE.Color(0xffff00);
            const green = new THREE.Color(0x44ff44);
            
            if (quality < 50) {
                return red.lerp(yellow, quality / 50);
            } else {
                return yellow.lerp(green, (quality - 50) / 50);
            }
        }

        function getQualityColorForCanvas(quality) {
            if (quality === null || quality === undefined) return '#3BA99C'; // Default calm teal

            quality = Math.max(0, Math.min(100, quality));
            let r, g;

            if (quality < 50) {
                // Red (255, 0, 0) to Yellow (255, 255, 0)
                r = 255;
                g = Math.round(255 * (quality / 50));
            } else {
                // Yellow (255, 255, 0) to Green (0, 255, 0)
                r = Math.round(255 * (2 - quality / 50));
                g = 255;
            }
            const b = 0;

            const toHex = (c) => c.toString(16).padStart(2, '0');
            return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
        }

        function updateSkeleton(landmarks, quality) {
            skeleton.clear();
            if (!landmarks) return;

            const jointColor = 0xffffff;
            let boneColor = 0x0088ff;
            if (quality !== null) {
                boneColor = getQualityColor(quality);
            }

            const jointMaterial = new THREE.MeshBasicMaterial({ color: jointColor });
            const boneMaterial = new THREE.LineBasicMaterial({ color: boneColor });

            landmarks.forEach(lm => {
                const joint = new THREE.Mesh(new THREE.SphereGeometry(0.02, 8, 8), jointMaterial);
                joint.position.set( (lm.x - 0.5) * -2, -(lm.y - 0.5) * 2, -lm.z * 2 );
                skeleton.add(joint);
            });
            
            POSE_CONNECTIONS.forEach(conn => {
                if (landmarks[conn[0]] && landmarks[conn[1]]) {
                    const points = [
                        new THREE.Vector3((landmarks[conn[0]].x - 0.5) * -2, -(landmarks[conn[0]].y - 0.5) * 2, -landmarks[conn[0]].z * 2),
                        new THREE.Vector3((landmarks[conn[1]].x - 0.5) * -2, -(landmarks[conn[1]].y - 0.5) * 2, -landmarks[conn[1]].z * 2)
                    ];
                    skeleton.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(points), boneMaterial));
                }
            });
        }
        
        function drawAngleIndicatorsOnCanvas(angles, landmarks, ctx) {
            ctx.fillStyle = 'yellow';
            ctx.font = '18px Arial';
            ctx.save();
            ctx.scale(-1, 1); // Flip context to match mirrored video
            const canvasWidth = ctx.canvas.width;

            if (landmarks[14]) { // Right Elbow
                ctx.fillText(`${Math.round(angles.rightElbow)}°`, -landmarks[14].x * canvasWidth + 10, landmarks[14].y * ctx.canvas.height);
            }
            if (landmarks[13]) { // Left Elbow
                ctx.fillText(`${Math.round(angles.leftElbow)}°`, -landmarks[13].x * canvasWidth - 50, landmarks[13].y * ctx.canvas.height);
            }
            if (landmarks[26]) { // Right Knee
                ctx.fillText(`${Math.round(angles.rightKnee)}°`, -landmarks[26].x * canvasWidth + 10, landmarks[26].y * ctx.canvas.height);
            }
            if (landmarks[25]) { // Left Knee
                ctx.fillText(`${Math.round(angles.leftKnee)}°`, -landmarks[25].x * canvasWidth - 50, landmarks[25].y * ctx.canvas.height);
            }
            ctx.restore();
        }

        /* Start camera stream - not that permissions need to be granted / webbrowser settings need to allow for the use of the camera */
        async function startCamera() {
            if (isCameraOn) return;
            try {
                videoElement = document.getElementById('input_video');
                // Move video element to the current view's container
                const currentVideoContainer = document.querySelector(isTwoScreenMode ? '#two-screen-layout .video-container' : '#one-screen-layout .video-container');
                currentVideoContainer.appendChild(videoElement);
                currentVideoContainer.appendChild(document.getElementById('output_canvas'));
                
                document.getElementById('output_canvas').width = 640;
                document.getElementById('output_canvas').height = 480;
                document.getElementById('status').textContent = 'Requesting camera...';
                const stream = await navigator.mediaDevices.getUserMedia({ video: { width: { ideal: 640 }, height: { ideal: 480 } } });
                videoElement.srcObject = stream;
                await new Promise(resolve => { videoElement.onloadedmetadata = () => { videoElement.play(); resolve(); }; });
                
                isCameraOn = true;
                document.getElementById('status').textContent = 'Camera started';
                cameraLoop();
            } catch (error) {
                document.getElementById('status').textContent = 'Error: Could not access camera.';
                console.error(error);
            }
        }
        
        function stopCamera() {
            if (videoElement && videoElement.srcObject) {
                videoElement.srcObject.getTracks().forEach(track => track.stop());
                videoElement.srcObject = null;
            }
            isCameraOn = false;
            cancelAnimationFrame(cameraLoopId);
            document.getElementById('status').textContent = 'Camera stopped';
        }

        // --- Session History Functions ---
        /* Save sessions info in the local storage of the web browser - can be accessed even after closing the application */
        function saveSession(exerciseName, sets, reps, quality) {
            const session = {
                date: new Date().toLocaleString(),
                exercise: exerciseName,
                sets: sets,
                reps: reps,
                quality: quality
            };
            let history = JSON.parse(localStorage.getItem('physioHistory')) || [];
            history.push(session);
            localStorage.setItem('physioHistory', JSON.stringify(history));
            displayHistory();
            renderProgressChart();
            updateAllTimeStats();
        }

        function loadHistory() {
            displayHistory();
            updateAllTimeStats();
        }

        function displayHistory() {
            const historyLog = document.getElementById('history-log');
            const history = JSON.parse(localStorage.getItem('physioHistory')) || [];
            historyLog.innerHTML = ''; 
            
            if (history.length === 0) {
                historyLog.innerHTML = '<p>No sessions recorded yet.</p>';
                return;
            }

            history.reverse().forEach(session => {
                const item = document.createElement('div');
                item.className = 'history-item';
                item.innerHTML = `
                    <span><strong>${session.exercise}</strong> - ${session.date}</span>
                    <span>${session.sets} Sets, ${session.reps} Reps, ${session.quality} Quality</span>
                `;
                historyLog.appendChild(item);
            });
        }

        function updateAllTimeStats() {
            const history = JSON.parse(localStorage.getItem('physioHistory')) || [];
            
            // Squat Stats
            const squatHistory = history.filter(s => s.exercise === 'Squat');
            const squatTotalReps = squatHistory.reduce((sum, s) => sum + s.reps, 0);
            const squatTotalSets = squatHistory.reduce((sum, s) => sum + s.sets, 0);
            const squatBestQuality = squatHistory.length > 0 ? Math.max(...squatHistory.map(s => parseFloat(s.quality) || 0)) + '%' : '--';
            document.getElementById('squat-total-reps').textContent = squatTotalReps;
            document.getElementById('squat-total-sets').textContent = squatTotalSets;
            document.getElementById('squat-best-quality').textContent = squatBestQuality;

            // Bicep Curl Stats
            const curlHistory = history.filter(s => s.exercise === 'Bicep Curl');
            const curlTotalReps = curlHistory.reduce((sum, s) => sum + s.reps, 0);
            const curlTotalSets = curlHistory.reduce((sum, s) => sum + s.sets, 0);
            const curlBestQuality = curlHistory.length > 0 ? Math.max(...curlHistory.map(s => parseFloat(s.quality) || 0)) + '%' : '--';
            document.getElementById('bicep_curl-total-reps').textContent = curlTotalReps;
            document.getElementById('bicep_curl-total-sets').textContent = curlTotalSets;
            document.getElementById('bicep_curl-best-quality').textContent = curlBestQuality;
        }

        // --- Progress Chart Function ---
        function renderProgressChart(exerciseName = 'Squat') {
            const ctx = document.getElementById('progress-chart').getContext('2d');
            const history = JSON.parse(localStorage.getItem('physioHistory')) || [];
            
            const exerciseData = history.filter(s => s.exercise === exerciseName).slice(-10);

            const labels = exerciseData.map(s => new Date(s.date).toLocaleDateString());
            const qualityData = exerciseData.map(s => parseFloat(s.quality) || 0);

            if (progressChart) {
                progressChart.destroy();
            }

            progressChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: `Average ${exerciseName} Quality (%)`,
                        data: qualityData,
                        borderColor: 'rgba(59, 169, 156, 1)',
                        backgroundColor: 'rgba(59, 169, 156, 0.2)',
                        fill: true,
                        tension: 0.1
                    }]
                },
                options: {
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: 100
                        }
                    }
                }
            });
        }
        
        function startRestTimer(duration) {
            isResting = true;
            let timer = duration;
            const timerElOne = document.getElementById('rest-timer-one-screen');
            const timerElTwo = document.getElementById('rest-timer-two-screen');

            const updateTimerText = () => {
                const text = `Rest: ${timer}s`;
                if(timerElOne) timerElOne.textContent = text;
                if(timerElTwo) timerElTwo.textContent = text;
            };
            
            updateTimerText();
            speak(`Rest for ${duration} seconds.`);

            restTimerId = setInterval(() => {
                timer--;
                updateTimerText();
                if (timer <= 0) {
                    clearInterval(restTimerId);
                    isResting = false;
                    if(timerElOne) timerElOne.textContent = '';
                    if(timerElTwo) timerElTwo.textContent = '';
                    speak("Time to start the next set!");
                }
            }, 1000);
        }
        
        function toggleView() {
            isTwoScreenMode = !isTwoScreenMode;
            const twoScreenLayout = document.getElementById('two-screen-layout');
            const oneScreenLayout = document.getElementById('one-screen-layout');
            
            if (isTwoScreenMode) {
                twoScreenLayout.style.display = 'grid';
                oneScreenLayout.style.display = 'none';
            } else {
                twoScreenLayout.style.display = 'none';
                oneScreenLayout.style.display = 'grid';
            }
            // Move video elements to the correct container
             const currentVideoContainer = document.querySelector(isTwoScreenMode ? '#two-screen-layout .video-container' : '#one-screen-layout .video-container');
             currentVideoContainer.appendChild(videoElement);
             currentVideoContainer.appendChild(document.getElementById('output_canvas'));

             if(isTwoScreenMode && renderer){
                 setTimeout(() => {
                     const container = document.getElementById('threejs-container');
                     renderer.setSize(container.clientWidth, container.clientHeight);
                     camera.aspect = container.clientWidth / container.clientHeight;
                     camera.updateProjectionMatrix();
                 }, 0);
             }
        }

        // --- EVENT LISTENERS ---
        /* Manage button clicks */
        document.querySelectorAll('.start-exercise-btn').forEach(button => {
            button.addEventListener('click', (e) => {
                const exerciseKey = e.target.dataset.exercise;
                startExercise(exerciseKey);
            });
        });

        document.getElementById('stop-exercise-btn').addEventListener('click', stopExercise);
        document.getElementById('stop-exercise-btn-one-screen').addEventListener('click', stopExercise);

        document.getElementById('toggle-view-btn').addEventListener('click', toggleView);
        document.getElementById('toggle-view-btn-one-screen').addEventListener('click', toggleView);

        /* Mute/Unmute voice assistant */
        const muteHandler = () => {
            isMuted = !isMuted;
            const muteBtn1 = document.getElementById('mute-btn');
            const muteBtn2 = document.getElementById('mute-btn-one-screen');
            const text = isMuted ? '🔇 Unmute' : '🔊 Mute';
            muteBtn1.textContent = text;
            muteBtn2.textContent = text;
            if (isMuted && synth.speaking) {
                synth.cancel();
            }
        };
        document.getElementById('mute-btn').addEventListener('click', muteHandler);
        document.getElementById('mute-btn-one-screen').addEventListener('click', muteHandler);

        /* Close button on the summary modal */
        document.getElementById('close-summary').addEventListener('click', () => {
            document.getElementById('summary-modal').style.display = 'none';
            resetExerciseState();
            document.getElementById('selection-screen').classList.add('active');
            document.getElementById('exercise-screen').classList.remove('active');
        });
        
        /* Tabs for switching between exercise charts */
        document.querySelectorAll('.chart-tab').forEach(tab => {
            tab.addEventListener('click', (e) => {
                document.querySelectorAll('.chart-tab').forEach(t => t.classList.remove('active'));
                e.target.classList.add('active');
                const exerciseName = e.target.dataset.exercise;
                renderProgressChart(exerciseName);
            });
        });
        
        /* Emoji feedback buttons on the summary modal */
        document.querySelectorAll('.emoji').forEach(emoji => {
            emoji.addEventListener('click', (e) => {
                document.querySelectorAll('.emoji').forEach(el => el.classList.remove('selected'));
                e.target.classList.add('selected');
            });
        });
        
        // --- DOM LOADED ---
        /* fired as soon as the HTML gets loaded */
        document.addEventListener('DOMContentLoaded', async () => {
            initThreeJS();
            try {
                await initMediaPipe();
            } catch (error) {
                document.getElementById('status').textContent = 'Failed to load AI model.';
                console.error(error);
            }
            loadHistory();
            renderProgressChart();
            renderLoop();
        });
    </script>
</body>
</html>




